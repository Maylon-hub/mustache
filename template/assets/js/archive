//    Manual medoid Extraction
//    
//    var roots = {}
//
//    Object.keys(data).forEach(function (key) {
//        var leafs = data[key].leaves();
//        var newarr = [];
//        for (i = 0; i < leafs.length; i++) {
//            newarr.push(leafs[i].data.label);
//        }
//
//        roots[key] = newarr.map(function(a){return a-2;});
//    });
//
//
//    d3.text("data/data4.csv", getMed)
//
//    function getMed(vals) {
//
//        var rows = d3.csvParseRows(vals);
//        var medoids = [];
//            
//        Object.keys(roots).forEach(function (key) {
//            var leafs = roots[key];
//
////            console.log(leafs);
//            
//            var temp = [],
//                start = leafs[0],
//                end = leafs[leafs.length-1];
//            
//            leafs.forEach(function(i){
//                slice = rows[i].slice(start, end);
//                sm = d3.sum(slice.map(function(d,i){
//                    return 1.0-d;
//                }));
//                temp.push(sm);
//            })
//            
////            console.log(temp);
//            
//            medoids.push(leafs[temp.indexOf(d3.min(temp))]+2);
//        });
//        
//        
//
//        }

.on("mousemove", function () {
            v = d3.mouse(this);
            sel = Math.floor(xtip(v[0]));
            d3.selectAll(".bar").style("fill", function (d, i) {

                if (i == sel) {
                    j = barData.mapping.indexOf(String(d[1]));

                    region = d3.select(".tooltip-region")
                    data = region.selectAll("span").data([i]);

                    data.enter().append("span").html(function () {
                        return d[0] + " " + d[1];
                    });
                    data.html(function () {
                        return d[0] + " " + d[1];
                    });
                    data.exit().remove();

                    region.select("#tip-color").style("background-color", function () {
                        var b = barData.color[d[1]]
                        return colorScale(barColoring[b]);
                    });

                    return "black";

                } else {

                    var b = barData.color[d[1]]
                    return colorScale(barColoring[b]);
                }
            });
        })





function MultiReachabilityPlots() {
    var margin = {
            top: 0,
            right: 0,
            bottom: 20,
            left: 0
        },

        width = $("#reach-panel").find(".panel-body").attr("width"),
        height = $("#reach-panel").find(".panel-body").attr("height") - 10;

    charts = []
    mpts = [9, 27, 35, 46]

    var colorScale = d3.scaleSequential(globalColor)
        .domain([0, 3]);

    d3.text('data/data3.csv', createChart);

    function createChart(data) {

        var rows = d3.csvParseRows(data);

        var charts = [];

        var chartHeight = height * (1 / rows.length);

        colorScale.domain([0, rows.length]);

        for (var i = 0; i < rows.length; i++) {

            charts.push(new Chart({
                data: rows[i].map(function (d) {
                    return +d;
                }),
                id: i,
                name: "UK",
                width: width,
                height: height,
                margin: margin,
                showBottomAxis: (i == rows.length - 1),
                m: mpts[i],
                rows: rows.length
            }));

        }
    }

    function Chart(options) {
        this.chartData = options.data;
        this.width = options.width;
        this.height = options.height;
        this.svg = options.svg;
        this.id = options.id;
        this.name = options.name;
        this.margin = options.margin;
        this.showBottomAxis = options.showBottomAxis;
        this.mpts = options.m;
        this.rows = options.rows;

        this.rows = 6;

        colW = parseInt(12 / this.rows);

        //        .append("a")
        //            .attr("data-toggle","modal")
        //            .attr("data-target","#exampleModalCenter")
        //            .attr("href","#")


        var svgCont = d3.select("#reach-plot")
            .append("div")
            .classed("col-xs-" + colW, "true")
            .classed("chart-scroller", "true")
            .classed("nopadding", "true");

        var chartXScale = (this.width / this.rows) - (this.margin.right + this.margin.left + 40),
            chartYScale = this.height - (this.margin.top + this.margin.bottom);

        var svg = svgCont.append("svg")
            .attr("id", "chart" + this.id)
            .attr("preserveAspectRatio", "xMinYMin meet")
            .attr("viewBox", "-40 " + (-(this.margin.top + this.margin.bottom) / 2) + " " + options.width / this.rows + " " + (options.height));



        /* XScale is based on the number of points to be plotted */
        this.xScale = d3.scaleLinear()
            .range([0, chartXScale])
            .domain([0, this.chartData.length - 1]);


        /* YScale is linear based on the maxData Point we found earlier */
        this.yScale = d3.scaleLinear()
            .range([chartYScale, 0])
            .domain([0, d3.max(this.chartData)]);

        var xS = this.xScale;
        var yS = this.yScale;

        /*
          This is what creates the chart.
          There are a number of interpolation options.
          'basis' smooths it the most, however, when working with a lot of data, this will slow it down
        */


        this.height = chartYScale;
        this.width = chartXScale;

        this.area = d3.area()
            .curve(d3.curveBasis)
            .x(function (d, i) {
                return xS(i);
            })
            .y0(this.height)
            .y1(function (d) {
                return yS(d);
            });

        /*
          This isn't required - it simply creates a mask. If this wasn't here,
          when we zoom/panned, we'd see the chart go off to the left under the y-axis
        */
        svg.append("defs").append("clipPath")
            .attr("id", "clip-" + this.id)
            .append("rect")
            .attr("width", this.width)
            .attr("height", this.height);

        svg.select("defs")
            .append("linearGradient")
            .attr("id", "grad-" + this.id)
            .attr("x1", "0%").attr("y1", "0%")
            .attr("x2", "0%").attr("y2", "100%")

        d3.select("#grad-" + this.id).append("stop").attr("offset", "0%").style("stop-color", d3.color(colorScale(this.id)).brighter(1)).style("stop-opacity", "1.0")
        d3.select("#grad-" + this.id).append("stop").attr("offset", "100%").style("stop-color", colorScale(this.id)).style("stop-opacity", "1.0");
        
        //                svg.select("defs")
//                    .append("linearGradient")
//                    .attr("id", "grad-" + this.id)
//                    .attr("x1", "0%").attr("y1", "0%")
//                    .attr("x2", "0%").attr("y2", "100%")
//
//                d3.select("#grad-" + this.id).append("stop").attr("offset", "0%").style("stop-color", d3.color(colorScale(medoids[this.id])).brighter(1)).style("stop-opacity", "1.0")
//                d3.select("#grad-" + this.id).append("stop").attr("offset", "100%").style("stop-color", colorScale(medoids[this.id])).style("stop-opacity", "1.0");
        
        
        

        this.chartContainer = svg.append("g")
            .attr("transform", "translate(" + this.margin.left + "," + "0" + ")");

        this.chartContainer.append("path")
            .data(this.id)
            .attr("class", "chart")
            .attr("clip-path", "url(#clip-" + this.id + ")")
            .style("fill", "url(#grad-" + this.id + ")")
            //            .style("stroke",colorScale(this.id))
            //            .style("stroke-width","3px")
            .attr("d", this.area);


        //        .style("fill", colorScale(this.id))

        this.yAxis = d3.axisLeft().scale(this.yScale).ticks(5);

        this.chartContainer.append("g")
            .attr("class", "y axis")
            .attr("transform", "translate(-10,0)")
            .call(this.yAxis);

        //        this.chartContainer.append("text")
        //            .attr("class", "country-title")
        //            .attr("transform", "translate(" + (chartXScale-150) + ",20)")
        //            .text("mpts: " + this.mpts);

    }

    Chart.prototype.showOnly = function (b) {
        this.xScale.domain(b);
        this.chartContainer.select("path").data([this.chartData]).attr("d", this.area);
        this.chartContainer.select(".x.axis.top").call(this.xAxisTop);
        this.chartContainer.select(".x.axis.bottom").call(this.xAxisBottom);
    }

}